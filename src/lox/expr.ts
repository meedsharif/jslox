/* generated by generateAst.ts */

import { Token } from './token';
class Expr {
  accept (visitor: any) {}
}

class Assign extends Expr {
  public name: Token;
  public value: Expr;
  constructor (name: Token, value: Expr) {
    super()
    this.name = name;
    this.value = value;
  }

  accept (visitor: any) {
    return visitor.visitAssignExpr(this)
  }
}

class Binary extends Expr {
  public left: Expr;
  public operator: Token;
  public right: Expr;
  constructor (left: Expr, operator: Token, right: Expr) {
    super()
    this.left = left;
    this.operator = operator;
    this.right = right;
  }

  accept (visitor: any) {
    return visitor.visitBinaryExpr(this)
  }
}

class Call extends Expr {
  public callee: Expr;
  public paren: Token;
  public args: Expr[];
  constructor (callee: Expr, paren: Token, args: Expr[]) {
    super()
    this.callee = callee;
    this.paren = paren;
    this.args = args;
  }

  accept (visitor: any) {
    return visitor.visitCallExpr(this)
  }
}

class Grouping extends Expr {
  public expression: Expr;
  constructor (expression: Expr) {
    super()
    this.expression = expression;
  }

  accept (visitor: any) {
    return visitor.visitGroupingExpr(this)
  }
}

class Literal extends Expr {
  public value: any;
  constructor (value: any) {
    super()
    this.value = value;
  }

  accept (visitor: any) {
    return visitor.visitLiteralExpr(this)
  }
}

class Logical extends Expr {
  public left: Expr;
  public operator: Token;
  public right: Expr;
  constructor (left: Expr, operator: Token, right: Expr) {
    super()
    this.left = left;
    this.operator = operator;
    this.right = right;
  }

  accept (visitor: any) {
    return visitor.visitLogicalExpr(this)
  }
}

class Unary extends Expr {
  public operator: Token;
  public right: Expr;
  constructor (operator: Token, right: Expr) {
    super()
    this.operator = operator;
    this.right = right;
  }

  accept (visitor: any) {
    return visitor.visitUnaryExpr(this)
  }
}

class Variable extends Expr {
  public name: Token;
  constructor (name: Token) {
    super()
    this.name = name;
  }

  accept (visitor: any) {
    return visitor.visitVariableExpr(this)
  }
}

export {
  Assign,
  Binary,
  Call,
  Grouping,
  Literal,
  Logical,
  Unary,
  Variable,
  Expr
}
